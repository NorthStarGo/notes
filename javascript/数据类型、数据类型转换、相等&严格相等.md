# 数据类型、数据类型转换、相等&严格相等

## 数据类型分类
基本数据类型：String,boolean,Number,Symbol（ES6新增）,Undefined, Null

引用数据类型：Object

基本数据类型中有两个为特殊数据类型： null, undefined
 
js的常见内置对象：Date,Array,Math,Number,Boolean,String,Array,RegExp,Function...

## 数据类型转换

### 隐式转换

```
undefined == null;  // true   
1 == true;  // true  
2 == true;  // false  
0 == false;  // true
0 == '';  // true   
NaN == NaN;  // false  NaN不等于任何值
[] == false;  // true  
[] == ![];  // true
'6' - '3'  // 3
1234 + 'abcd' // "1234abcd"

```

1. undefined与null相等，但不恒等（===）
1. 一个是number一个是string时，会尝试将string转换为number
1. 隐式转换将boolean转换为number，0或1
1. 隐式转换将Object转换成number或string，取决于另外一个对比量的类型
1. 对于0、空字符串的判断，建议使用 “===” 。
1. “==”会对不同类型值进行类型转换再判断，“===”则不会。它会先判断两边的值类型，类型不匹配时直接为false。

### 显示转换

显示转换一般指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。

#### Number：

```
Number('1234') // 1234
Number('1234abcd') // NaN
Number('') // 0
Number(true) // 1
Number(null) // 0
Number(undefined) // NaN

```

#### String：

```
String(1234)  // "1234"
String('abcd')  // "abcd"
String(true)  // "true"
String(undefined) // "undefined"
String(null)  // "null"

```

#### Boolean:

```
Boolean(0)  // false
Boolean(undefined)  // false
Boolean(null)  // false
Boolean(NaN)  // false
Boolean('')  // false

```

Number、String、Boolean转换对象时主要使用了对象内部的valueOf和toString方法进行转换。

#### Number转换对象：

1. 先调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，返回结果。
1. 如果valueOf返回的还是对象，继续调用对象自身的toString方法。如果toString返回原始类型的值，则对该值使用Number函数，返回结果。
1. 如果toString返回的还是对象，报错。

```
Number([1]); //1
转换演变：
[1].valueOf(); // [1];
[1].toString(); // '1';
Number('1'); //1

```

#### String转换对象

1. 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，返回结果。
1. 如果toString返回的是对象，继续调用valueOf方法。如果valueOf返回原始类型的值，则对该值使用String函数，返回结果。
1. 如果valueOf返回的还是对象，报错。

```
String([1,2]) //"1,2"
转化演变：
[1,2].toString();  //"1,2"
String("1,2");  //"1,2"
```

#### Boolean转换对象

Boolean转换对象很特别，除了以下六个值转换为false，其他都为true

```
undefined  null  false  0(包括+0和-0)  NaN  空字符串('')
Boolean(undefined)   //false
Boolean(null)        //false
Boolean(false)       //false
Boolean(0)           //false
Boolean(NaN)         //false
Boolean('')          //false

Boolean([])          //true
Boolean({})          //true
Boolean(new Date())  //true

```
### 严格相等运算符和相等运算符的区别：

==相等运算符比较两个值的时候会判断两个值的类型，如果不是同一类型，会强制转换为同一类型进行比较。


而===比较两个值的时候先判断两个值的类型，如果不是同一类型，直接返回false，值类型相同再进行值的比较。


所以，从性能上来说，==会比===多走一条类型转换的路，稍逊一点。从结果上来说，有时候类型转换会给你带来你不想要的比较结果。 这也就是为什么都推崇使用===的原因。当然，==在合适的业务场景下使用也是必要的。

### 相等运算符==

```
规则： 

if 相等运算符比较相同类型的数据时，同严格相等运算符
else if 相等运算符比较不同类型的数据时：
原始类型的数据会转换成数值类型，把字符串和布尔值都转为数值，再进行比较
null == undefined  返回true
一个是对象，另一个是数字或者字符串，把对象转成基本类型值再比较
else false

123 == 123; //true
'123' == 123; //true，'123'会转成成数值123
false == 0; //true，false 转成数值就是0
'a' == 'A'; //false，转换后的编码不一样
123 == {}; //false，执行toString()或valueOf()会改变
123 == NaN; //false，只要有NaN，都是false
{} == {}; //false，比较的是他们的地址，每个新创建对象的引用地址都不同

null == undefined //true
'NaN' == NaN //false
123 == NaN //false
NaN == NaN //false
false == 0 //true
true == 1 //true
true == 2 //false
undefined == 0 //false
null == 0 //false
'123' == 123 //true
'123' === 123 //false
```

### !!判断

!!相当于Boolean，写代码时用!!转化为Boolean类型做判断非常好用

```
!!'xzavier';   // true
!!'';          // false
!!'0';         // true
!!'1';         // true
!!'-1'         // true
!!0            // false
!!undefined    // false
!!null         // false
!!NaN          // false
!!{};          // true
!!{name:'xz'}  // true
!![];          // true
!![1,2,3];     // true
!!true;        // true
```
### !判断

取反运算符 ! 用于将布尔值变为相反值，即true变成false，false变成true。对于非布尔值的数据，取反运算符会自动将其转为布尔值。规则是，以下六个值取反后为true，其他值取反后都为false

```
undefined  null  false  0(包括+0和-0)  NaN  空字符串('')

!undefined    // true
!null         // true
!false        // true
!0            // true
!NaN          // true
!""           // true    
!54           // false
!'hello'      // false
![]           // false
![1,2,3]      // false
!{}           // false
!{name:'xz'}  // false
```

### []和{}判断

对于[]和{}，我们在业务代码中肯定会对其做判断，如上

```
!!{};          // true
!!{name:'xz'}  // true
!![];          // true
!![1,2,3];     // true

```

不能用!!和!做判断，对于数组，我们用它的length属性做判断

```
[].length       // 0 false
[1,2,3].length  // 3 true

```
参考资料：

[相等==&严格相等===&代码里的那些判断](https://segmentfault.com/a/1190000006672446)

[基本数据类型和引用数据类型判断&存储访问&类型转换](https://segmentfault.com/a/1190000005863067)