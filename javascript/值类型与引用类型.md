# 值类型与引用类型

* 基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值；
* 引用类型的值是保存在内存中的对象，在操作对象时，实际上是在操作对象的引用而不是实际的对象；

## 值类型

如果一个变量存储的是值的本身那么就是一个值类型number / string / Boolean / Null / Undefined —值类型的变量本身就是含有赋予给它的数值的，它的变量本身及保存的数据都存储在栈的内存块当中，当声明一个值类型时，必须对它初始化（给变量赋值）才能使用

```
var num1 = 123,
    num2 = num1;
num1 = 456;
console.log(num2);// 123
```

将值类型复制给另外一个值时(num2=num1)，也就是num2重新再栈上开辟了一块空间，然后将num1中的内容复制一份放在num2中，当改变其中一个变量的值时，不会影响另外一个变量的值

![](https://segmentfault.com/img/bVYwRA?w=1382&h=492)

## 引用类型

如果一个变量存储的是引用（地址），那么就是一个引用类型object—引用类型的值的存储与值类型不同，它分别存储在内存的堆和栈中，**栈中存放的是指向堆中内容的地址，堆中存放的引用类型的地址(键值对)**

```
var obj1 = {name: "xyc"};
var obj2 = obj1;
obj1.name = "lxy";
console.log(obj2.name); // "lxy"
```

obj2=obj1表示的是将栈上的地址复制一份给另一个对象，他们同时指向堆中的内容，当修改内容时，两个对象中的值都会发生改变

![](https://segmentfault.com/img/bVYwRG?w=1048&h=488)

### 一个面试题

```
var o = new Object();
function foo(obj) {
  obj.name = "xyc";
  obj = new Object();
    obj.name = "lxy";
}
foo(o);
console.log(o.name); // ???
```

图解：

（1）新建对象var o = new Object();

![](https://segmentfault.com/img/bVYwRK?w=1064&h=494)

（2）在foo的环境下执行obj.name = "xyc"
由于是参数传递，在局部作用域内相当于执行了obj = o

![](https://segmentfault.com/img/bVYwRS?w=1024&h=468)

（3）在局部作用域内新建对象，并赋值相同的属性值

`obj = new Object();
obj.name = "lxy";`

![](https://segmentfault.com/img/bVYwR1?w=1026&h=476)

（4）foo()执行完毕，局部作用域出栈，obj声明周期结束
此时，新建的对象依然存在，等待下一次内存自动回收机制将堆中的无引用对象销毁

![](https://segmentfault.com/img/bVYwR9?w=1038&h=470)


### 堆&栈

* 两者都是存放临时数据的地方。
* 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。
* 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。
* 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 
* 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 
* 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 
* 栈（数据结构）：一种先进后出的数据结构。


参考资料：

[值类型与引用类型](https://segmentfault.com/a/1190000010641791)